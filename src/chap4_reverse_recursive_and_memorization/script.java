package chap4_reverse_recursive_and_memorization;

public class script {
    /**
     *  在生产环境中，显示的调用递归会导致栈溢出，主要是Java 栈的有限性，但是为了解决这个问题
     *  需要在编码的时候将基于栈转换为基于堆的函数，从而避免栈的有限性，
     *  为了使得递归更加的安全，你应该使用对代替栈的悠闲空间
     *
     *  反递归和递归
     *      返递归：每一步的输出作为下一步的输入，
     *      递归：和上面相同，但是它是在最后一步开始，在递归中，必须延迟赋值，直至遇到基本终止条件，在这个过程中，所有的过程都被压到
     *          栈中，二栈式有限的，所以才会出现溢出。
     *
     *  Java 中试如何处理方法调用：
     *      当调用一个方法的时候，Java暂停手上正在处理的事情，并将环境推入到栈中，为执行被调用的方法提供一个为止，当方法返回的时候
     *      Java 弹出栈以恢复先前的环境并继续执行程序，如果你频繁的调用方法，栈总是为这些方法持有一个调用的环境
     *      方法调用可能被深度切套，而嵌套的深度式有一定的限制的，那就是栈的大小
     *
     *  使用尾递归消除调用：
     *      如果方法做的最后一件事情是调用某一个方法，当此方法返回时就并没有什么恢复的了，也一味这它是返回之前要做的最后一件事情，
     *      递归调用必须是方法所做的最后一件事情，
     *
     *  recurrent 中的 sumV1 并不是尾递归，在方法执行的最后做了4节事情， 调用 head 方法，调用 tail 方法，调用 sumV1 方法， + 操作
     *  但是 sumV2 是一个尾递归，只需要一直往深的嵌套计算，而并不需要将中间的环境
     *
     *  使用反递归，每一步都是终止的，可以对他进行求职，然后作为下一步的输入，这一步的计算就结束了
     *  但是使用递归就不是这样的了，从一端开始，你必须将未求值得调用放在列表中，知道到达终止条件
     *  然后反序处理列表，处理栈中压入的前序环境
     *
     *  TCE: tail call elimination 尾调用消除优化技术，也就是上面提到的，方法调用的的最后一件事情是调用某一个方法，，且当此方法返回
     *      的时候并没有什么可以恢复，所以应该可以直接恢复为当前方法的调用者而不是当前方法自己，在尾部调用也意味着它是返回之前要做的
     *      最后一件事情，
     *  以上就是尾递归，或者是返递归
     *
     *  Java 是没有 TCE 优化
     *
     *  Java 不管是尾递归还是递归，都使用那个了线程栈，但是栈的容量是有限的，栈会在6000 - 7000步之后溢出。
     *  而在Java 中式可以解决这个问题的，你要做的就是创建一个返回未计算步骤的函数或者方法
     *
     *  解决这个问题：
     *  第一：
     *      TailCall 抽象类，表示你想要表示调用出现在尾部位置的方法
     *      TailCall 实现两个子类，第一个子类 Suspend 表示下一个递归调用，将每一个尾递归链接到下一个的方法来构造一个列表
     *      第二个子类是，Return 它不会持有到下一个TailCall 的连接
     *
     *  利用上面的方法我们构造了 sumV3 ， sumV3 是一个实例链，实例链 中间全部都是 Suspend 然后最后一个是 Return 类型，
     *  这个 sumV3 可以替换sumV1 或者 sumV2 么？至少现在是不行的，因为你要得到sumV3 的结果，你必须
     *  TailCall<Integer> integerTailCall = sumV3(3, 1000);
     *         while (integerTailCall.isSuspend()){
     *            integerTailCall = integerTailCall.resume();
     *         }
     *         integerTailCall.eval();
     *
     * 最直接的方法就是将上面的代码，都写到Suspend 类的 eval() 中
     * 使用一些辅助函数，就可以看着和普通的 add 方法一样的了 sumV4
     *
     * 如上的方法就完成了一个没有栈危险的，尾递归方法
     *
     * 总结来看： 实现该方法最重要的步骤就是，实现一个返回未执行的函数
     *
     * 再Java 中函数内部是不能定义函数的，但是lambda 表达式实际上是一个类，再该类中也是不能定义局部函数的，因为lambda 内部变量要求是 static final 的，你
     * 并不能构建建静态成员
     *
     * lambda 和 class 类的区别在于 lambda 中的 this 指向的是包含 lambda 表达式的class， 但是class 中的 this 是指向自己的。
     *
     * 斐波那契数列
     * f(0) = 0
     * f(1) = 1
     * f(n) = f(n-1) + f(n-2)
     *
     *
     **/
     }
