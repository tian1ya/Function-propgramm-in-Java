package chap4_reverse_recursive_and_memorization;

public class script {
    /**
     *  在生产环境中，显示的调用递归会导致栈溢出，主要是Java 栈的有限性，但是为了解决这个问题
     *  需要在编码的时候将基于栈转换为基于堆的函数，从而避免栈的有限性，
     *  为了使得递归更加的安全，你应该使用对代替栈的悠闲空间
     *
     *  反递归和递归
     *      返递归：每一步的输出作为下一步的输入，
     *      递归：和上面相同，但是它是在最后一步开始，在递归中，必须延迟赋值，直至遇到基本终止条件，在这个过程中，所有的过程都被压到
     *          栈中，二栈式有限的，所以才会出现溢出。
     *
     *  Java 中试如何处理方法调用：
     *      当调用一个方法的时候，Java暂停手上正在处理的事情，并将环境推入到栈中，为执行被调用的方法提供一个为止，当方法返回的时候
     *      Java 弹出栈以恢复先前的环境并继续执行程序，如果你频繁的调用方法，栈总是为这些方法持有一个调用的环境
     *      方法调用可能被深度切套，而嵌套的深度式有一定的限制的，那就是栈的大小
     *
     *  使用尾递归消除调用：
     *      如果方法做的最后一件事情是调用某一个方法，当此方法返回时就并没有什么恢复的了，也一味这它是返回之前要做的最后一件事情，
     *      递归调用必须是方法所做的最后一件事情，
     *
     *  recurrent 中的 sumV1 并不是尾递归，在方法执行的最后做了4节事情， 调用 head 方法，调用 tail 方法，调用 sumV1 方法， + 操作
     *  但是 sumV2 是一个尾递归，只需要一直往深的嵌套计算，而并不需要将中间的环境
     *
     *  使用反递归，每一步都是终止的，可以对他进行求职，然后作为下一步的输入，这一步的计算就结束了
     *  但是使用递归就不是这样的了，从一端开始，你必须将未求值得调用放在列表中，知道到达终止条件
     *  然后反序处理列表，处理栈中压入的前序环境
     */
}
