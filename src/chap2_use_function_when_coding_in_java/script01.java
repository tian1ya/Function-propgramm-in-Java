package chap2_use_function_when_coding_in_java;

public class script01 {
    /**
     *  函数柯里化：
     *      函数返回来的结果是另外函数，可以是多个，输入一个参数，返回来的式关于这个参数的函数
     *
     *  函数式需要满足以下：
     *      * 不能修改函数以外的任何东西，外部观测不到内部的任何变化
     *      * 它不能修改自己的参数
     *      * 它不能抛出异常或者错误
     *      * 它必须返回一个值
     *      * 只要调用它的参数相同，那么结果必须也是相同的。
     *
     *
     *
     *   使用函数式编程，及多肽，查看，符合复合函数的强大功能， 在命令式的编程中，需要将第一个函数的结果作为下一个函数的输入方式来计算
     *   但是在Java 8 的函数式的复合中，无需计算结果，而是直接构建计算结果，复合函数 如: 2_1
     *
     *
     *   配合Java8 的lambda 会更加的强大，既简化语法，而且还会进行类型推断: 如 2_2
     *
     *
     *   多参数函数，输入其中一个参数，返回这个参数的函数，也就是柯里化
     *   Function<Integer, Function<Interger, Interger>>*
     *          输入这个参数 -> 然后返回这个参数的函数(这个函数的作用是，输入一个正数，然后输出一个正数)
     *   使用lambda 写 就会很容易
     *    Interger -> Interger -> Interger
     *
     *   或者是(满足结合律)
     *      Interger -> (Interger -> Interger)
     *   如 2_3
     *   但是这里有一个问题就是随着返回值 Function<Integer, Function<Integer, Integer>> 越来越复杂，返回类型将会非常的累赘和麻烦
     *   Java 语法本省并不能解决这个问题，因为Java 不支持类型别名
     *   但是可以使用继承解决这个问题 如 2_3_1
     *
     *
     *   高阶函数：
     *      接受一个函数作为参数，返回另外一个函数 如 2_4
     *
     *   可以将高阶函数的参数泛型化，可以接受更多种的参数
     *
     *   在 lambda 或者 匿名函数中访问局部变量必须声明为 final 的，表明式不会被改变的 如：2_6
     *
     *   部分函数和柯里化的使用 如： partialApplicationAndCurry， 涉及到面向对象和部分应该的方式，！！！！！！！
     *   双参数柯里化
     *
     */
}
